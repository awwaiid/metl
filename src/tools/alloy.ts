/**
 * Alloy-related tools for the METL agent
 */

import { tool } from '@anthropic-ai/claude-agent-sdk';
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Tool to create an Alloy model from code concepts
 */
export const createAlloyModel = tool(
  'create_alloy_model',
  'Create an Alloy formal model based on identified code concepts and interactions. The model will be automatically saved to a .als file in the current working directory or specified output directory.',
  {
    modelName: z.string().describe('Name of the Alloy model'),
    concepts: z.array(z.string()).describe('List of core concepts to model'),
    relationships: z.array(z.string()).describe('Key relationships between concepts'),
    constraints: z.array(z.string()).describe('Constraints and invariants to enforce'),
    outputDir: z.string().optional().describe('Optional output directory (defaults to current directory)'),
  },
  async (args, context) => {
    // Build the Alloy model structure
    const alloyModel = buildAlloyModel(
      args.modelName,
      args.concepts,
      args.relationships,
      args.constraints
    );

    // Determine output directory - use provided dir, or context cwd, or current process cwd
    const outputDir = args.outputDir || (context as any).cwd || process.cwd();

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Create filename from model name
    const filename = `${args.modelName.replace(/\s+/g, '_').toLowerCase()}.als`;
    const filepath = path.join(outputDir, filename);

    // Write the model to file
    fs.writeFileSync(filepath, alloyModel, 'utf-8');

    return {
      content: [{
        type: 'text' as const,
        text: JSON.stringify({
          success: true,
          modelName: args.modelName,
          filepath,
          model: alloyModel,
          message: `Created Alloy model '${args.modelName}' with ${args.concepts.length} concepts and saved to ${filepath}`,
        }, null, 2),
      }],
    };
  }
);

/**
 * Tool to run an Alloy model and generate examples
 */
export const runAlloyModel = tool(
  'run_alloy_model',
  'Execute an Alloy model to generate example scenarios',
  {
    modelContent: z.string().describe('The Alloy model code'),
    command: z.string().describe('The Alloy command to run (e.g., "run", "check")'),
    scope: z.number().optional().describe('The scope for the analysis (default: 3)'),
  },
  async (args) => {
    // Note: alloy-lang package will be used to execute the model
    // For now, we'll return a placeholder structure
    const scope = args.scope ?? 3;

    return {
      content: [{
        type: 'text' as const,
        text: JSON.stringify({
          success: true,
          command: args.command,
          scope,
          message: 'Alloy model execution would happen here',
          examples: [],
          note: 'alloy-lang integration will be implemented to execute models',
        }, null, 2),
      }],
    };
  }
);

/**
 * Tool to translate Alloy examples into test code
 */
export const translateToTest = tool(
  'translate_to_test',
  'Translate an Alloy example scenario into a test case in the target language',
  {
    scenario: z.string().describe('The Alloy scenario to translate'),
    language: z.string().describe('Target programming language (e.g., Ruby, JavaScript, Python)'),
    framework: z.string().describe('Testing framework (e.g., RSpec, Jest, pytest)'),
    codeContext: z.string().describe('Relevant code context from the original codebase'),
  },
  async (args) => {
    return {
      content: [{
        type: 'text' as const,
        text: JSON.stringify({
          success: true,
          language: args.language,
          framework: args.framework,
          message: `Translated scenario to ${args.language} ${args.framework} test`,
          testCode: '// Test translation would be generated here based on the scenario',
          scenario: args.scenario,
        }, null, 2),
      }],
    };
  }
);

/**
 * Helper function to build an Alloy model
 */
function buildAlloyModel(
  name: string,
  concepts: string[],
  relationships: string[],
  constraints: string[]
): string {
  const header = `// Alloy Model: ${name}
// Generated by METL
// Date: ${new Date().toISOString()}

module ${name.replace(/\s+/g, '')}

`;

  const sigs = concepts.map(concept => {
    return `sig ${concept} {\n  // Add fields here\n}`;
  }).join('\n\n');

  const facts = constraints.map((constraint, idx) => {
    return `fact Constraint${idx + 1} {\n  // ${constraint}\n}`;
  }).join('\n\n');

  const preds = `
pred show {
  // Predicate to show instances
}

run show for 3
`;

  return header + sigs + '\n\n' + facts + '\n\n' + preds;
}

export const alloyTools = [
  createAlloyModel,
  runAlloyModel,
  translateToTest,
];
